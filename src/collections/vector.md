# 向量

向量（vector）类型`Vec<T>`与数组类似，允许我们在一个单独的数据结构中存储多个同一类型的值，这些值在内存中相邻地排列。不同的是，向量的长度可以动态地修改。

> `Vec<T>`使用了泛型语法`<T>`，表示这里需要传入一个泛型类型参数`T`。`Vec<T>`表示这是一个由`T`类型元素组成的向量。

## 新建向量

我们可以使用`Vec::new()`函数创建新的空向量，例如：

```rust
let v: Vec<i32> = Vec::new();
```

注意这里我们使用了一个类型注释`Vec<i32>`。因为我们新建的是一个空向量，编译器无法推断出我们想要储存什么类型的元素，所以我们需要告诉编译器`v`这个向量将存放`i32`类型的元素。

Rust提供了`vec!`宏用于更方便地定义和初始化一个向量：

```rust
let v = vec![1, 2, 3];
```

这段代码新建了一个存有值`1`、`2`和`3`的`Vec<i32>`，因为我们提供了`i32`类型的初始值，编译器可以推断出`v`的类型是`Vec<i32>`，因此类型注释可以省略。

## 访问向量元素

可以使用向量的`.push()`和`pop()`方法添加和删除末尾元素：

```rust
let mut v = Vec::new();
v.push(1);
v.push(2);
v.pop();
v.push(3);
println!("{:?}", v);
// #[1, 3]
```

可以使用索引语法访问数组元素：

```rust
let mut v = vec![1, 2, 3];
v[0] = v[1] + v[2];
println!("{:?}", v);
// #[5, 2, 3]
```

如果越界访问向量元素，将会引发程序崩溃，例如：

```rust,ignore,panics
let v = vec![1, 2, 3, 4, 5];
let does_not_exist = v[100];
```

这段代码发生运行时崩溃，错误信息如下：

```shell
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 100'
```

在后续学习Rust的错误处理的时候，我们可以使用`Vec::get`方法安全地访问向量，并处理未获取到值的情况。
